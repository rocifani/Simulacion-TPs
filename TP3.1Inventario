import random
import simpy

# Parámetros del sistema
tasa_arribo = 0.45
nivel_minimo_inventario = 15
nivel_maximo_inventario = 30
tiempo_demora_min = 0.5
tiempo_demora_max = 1.0
costo_faltante=5


# Variables de rendimiento
inventario_actual = 20
tot_pedidos=0
num_pedidos_entregados = 0
tiempo_total_espera = 0
tiempos_eventos = []  # Lista para almacenar los tiempos de los eventos
costo_pedido = 0
faltante=0
inventario=0
sum=0

# Probabilidades de demanda para 1, 2, 3 y 4 artículos
probabilidades_demanda = [1/6, 1/3, 1/3, 1/6]
demanda_articulos = [1, 2, 3, 4]

def generar_demanda():
    demanda = random.choices(demanda_articulos, probabilidades_demanda)[0]
    return demanda

def proceso_inventario(env):
    global inventario_actual, num_pedidos_entregados, tiempo_total_espera, tiempos_eventos, costo_pedido, tot_pedidos, faltante,inventario, sum

    pedido_pendiente = False  # Variable para controlar si hay un pedido pendiente
    tiempo_entrega = 0  # Tiempo de entrega actual del pedido
    n=1


    while env.now <= 720:

        tiempo_arribo = random.expovariate(tasa_arribo)

        inventario+=inventario_actual
        sum+=1

        # Avanzar en el tiempo (considerando el tiempo de entrega del pedido)
        yield env.timeout(tiempo_arribo)

        # Registrar tiempo de llegada de cliente
        tiempos_eventos.append(env.now)

        # Generar demanda
        demanda = generar_demanda()

        # Verificar si es necesario realizar un pedido
        if inventario_actual <= nivel_minimo_inventario and not pedido_pendiente and env.now>=30*n :
            # Realizar pedido
            num_pedidos_entregados += 1
            pedido_pendiente = True  # Hay un pedido pendiente
            tiempo_entrega = (random.uniform(tiempo_demora_min, tiempo_demora_max)) + env.now  # Calcular tiempo de entrega del pedido
            cant_ult_pedido = nivel_maximo_inventario - inventario_actual
            tiempos_eventos.append(env.now)  # Registrar tiempo en el que se realiza el pedido
            costo_pedido = costo_pedido + (32 + 3*cant_ult_pedido)
            n+=1
            print(f"{env.now:.2f}: Realizando pedido al proveedor (Inventario: {inventario_actual}), Tiempo de entrega: {tiempo_entrega:.2f}")

        # Verificar si ha llegado el pedido
        if pedido_pendiente and env.now >= tiempo_entrega:
            inventario_actual = inventario_actual + cant_ult_pedido # Actualizar el inventario con la cantidad del pedido
            pedido_pendiente = False  # El pedido ha sido entregado
            tiempos_eventos.append(env.now)  # Registrar tiempo en el que llega el pedido

        # Verificar si hay suficiente inventario para satisfacer la demanda
        if demanda <= inventario_actual:
            inventario_actual -= demanda
            print(f"{env.now:.2f}: Llegada de cliente: -{demanda} unidades (Inventario: {inventario_actual})")
        else:
            print(f"{env.now:.2f}: No hay suficientes productos disponibles.")
            faltante+=demanda

            if not pedido_pendiente:
                # No hay pedido pendiente, atender al cliente sin esperar
                print(f"{env.now:.2f}: Atendiendo al cliente sin esperar entrega de pedido...")
                inventario_actual -= demanda
                print(f"{env.now:.2f}: Llegada de cliente: -{demanda} unidades (Inventario: {inventario_actual})")
            else:
                # Hay un pedido pendiente, atender al cliente sin esperar entrega de pedido
                print(f"{env.now:.2f}: Atendiendo al cliente sin esperar entrega de pedido...")
                inventario_actual -= demanda
                print(f"{env.now:.2f}: Llegada de cliente: -{demanda} unidades (Inventario: {inventario_actual})")

# Configuración y ejecución de la simulación
env = simpy.Environment()
env.process(proceso_inventario(env))
env.run()

# Resultados
print("\nResultados de la simulación:")
print(f"Número de pedidos entregados: {num_pedidos_entregados}")
print(f"Inventario final: {inventario_actual}")
print(f"Costo de promedio de pedido: {costo_pedido/num_pedidos_entregados}")
print(f"Costo de promedio de faltante: {costo_faltante*faltante/num_pedidos_entregados}")
print(f"Costo de promedio de mantenimiento: {inventario/sum}")
print(f"Costo total:{(costo_pedido/num_pedidos_entregados)+(costo_faltante*faltante/num_pedidos_entregados)+(inventario/sum)}")
